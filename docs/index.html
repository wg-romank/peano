<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 1 - Peano</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Chapter 1</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Peano</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="peano"><a class="header" href="#peano">Peano</a></h1>
<p>Let's define some natural numbers on the type level first. We can start with 0 and use type constructor to create types of each element.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct _0;
struct Succ&lt;T&gt;(T);
<span class="boring">}
</span></code></pre></pre>
<p>We have to manually construct 1, 2, 3, ... at this point. It should be possible to workaround that using procedurial macro but we won't get into those details just yet.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct _0;
</span><span class="boring">struct Succ&lt;T&gt;(T);
</span>type _1 = Succ&lt;_0&gt;;
type _2 = Succ&lt;_1&gt;;
type _3 = Succ&lt;_2&gt;;
type _4 = Succ&lt;_3&gt;;
type _5 = Succ&lt;_4&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Since we will be defining some laws that are applicable to types we have just defined it is handy to define a trait to represent all of them.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct _0;
</span><span class="boring">struct Succ&lt;T&gt;(T);
</span>trait Nat {}
impl Nat for _0 {}
impl&lt;T: Nat&gt; Nat for Succ&lt;T&gt; {}
<span class="boring">}
</span></code></pre></pre>
<p>Now we are ready to define some of the properties those types should follow. In this post we will only consider less than (<code>&lt;</code>) but deriving various other laws should be analogous.</p>
<p>Let's define a trait <code>Lt</code> that would take two type parameters <code>A</code> and <code>B</code>. Semantic meaning of this trait would be relationship between types <code>A</code> and <code>B</code>, that is <code>A &lt; B</code> in terms of natural numbers.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Nat {}
</span>trait Lt&lt;A: Nat, B: Nat&gt; {}
<span class="boring">}
</span></code></pre></pre>
<p>Let's try to define laws that natural numbers follows in terms of these types in Rust notation. We will formalize it using induction:</p>
<ul>
<li><code>0</code> is less than any natural number, this is going to be base case of induction</li>
<li>for any <code>A</code> and <code>B</code>, such that <code>A</code> is less than <code>B</code> we can state that <code>Succ&lt;A&gt;</code> is less than <code>Succ&lt;B&gt;</code></li>
</ul>
<p>However before we define those rules using <code>impl</code> blocks as we dit for <code>Nat</code> trait we need to define additional type. When describing whether type is a natural number we used that particular type as a target to implement trait <code>Nat</code> for. In case of <code>Lt</code> relationship however we need to capture both types into that target type so let's create another struct and call it <code>ProofLt</code>, naming choice would more sense later.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Nat {}
</span>struct ProofLt&lt;A: Nat, B: Nat&gt;(A, B);
<span class="boring">}
</span></code></pre></pre>
<p>Now let's use <code>ProofLt</code> as a target type to define less than relationship.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Nat {}
</span><span class="boring">struct Succ&lt;T: Nat&gt;(T);
</span><span class="boring">struct _0;
</span><span class="boring">impl Nat for _0 {}
</span><span class="boring">impl&lt;T: Nat&gt; Nat for Succ&lt;T&gt; {}
</span><span class="boring">trait Lt&lt;A: Nat, B: Nat&gt; {}
</span><span class="boring">struct ProofLt&lt;A: Nat, B: Nat&gt;(A, B);
</span>impl&lt;N: Nat&gt; Lt&lt;_0, N&gt; for ProofLt&lt;_0, N&gt; {}
impl&lt;A: Nat, B: Nat&gt; Lt&lt;Succ&lt;A&gt;, Succ&lt;B&gt;&gt; for ProofLt&lt;Succ&lt;A&gt;, Succ&lt;B&gt;&gt;
    where ProofLt&lt;A, B&gt;: Lt&lt;A, B&gt; {}
<span class="boring">}
</span></code></pre></pre>
<p>We've encoded some rules but how do we actually check them? Let's use type bounds and helper methods for that.</p>
<p>First define a function to test whether all number types we have defined are indeed natural (implement <code>Nat</code>)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Nat {}
</span><span class="boring">struct Succ&lt;T: Nat&gt;(T);
</span><span class="boring">struct _0;
</span><span class="boring">impl Nat for _0 {}
</span><span class="boring">impl&lt;T: Nat&gt; Nat for Succ&lt;T&gt; {}
</span><span class="boring">type _1 = Succ&lt;_0&gt;;
</span><span class="boring">type _2 = Succ&lt;_1&gt;;
</span><span class="boring">type _3 = Succ&lt;_2&gt;;
</span>fn test_is_nat&lt;T: Nat&gt;() -&gt; () {}

fn main() {
    test_is_nat::&lt;_0&gt;();
    test_is_nat::&lt;_1&gt;();
    test_is_nat::&lt;_2&gt;();
    // ...
}
</code></pre></pre>
<p>Notice that the function is empty as we are only interested in types of our program.</p>
<p>Now to check whether <code>&lt;</code> is holding for some types <code>A</code> and <code>B</code> we could use our <code>ProofLt</code> struct to summon <code>Lt</code> trait implementations, but in order to do this we need to define some method on <code>Lt</code> trait we could call. In case method is found and compilation succeds we can conclude that <code>&lt;</code> property holds, otherwise it doesn't.</p>
<p>Let's amend our <code>Lt</code> definition with this extra function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Nat {}
</span>trait Lt&lt;A: Nat, B: Nat&gt; {
    fn check() -&gt; () {}
}
<span class="boring">}
</span></code></pre></pre>
<p>Semantially this function would mean that <code>Lt</code> property is holding and we should only be able to call this function on our target type <code>ProofLt</code> in case <code>Lt</code> indeed holds. Otherwise compiler should yell at us failing to find function definiton. Again we are not really interested in calling this function (thus empty body and argument lits), but whether it is there or not.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Nat {}
</span><span class="boring">struct Succ&lt;T: Nat&gt;(T);
</span><span class="boring">struct _0;
</span><span class="boring">impl Nat for _0 {}
</span><span class="boring">impl&lt;T: Nat&gt; Nat for Succ&lt;T&gt; {}
</span><span class="boring">type _1 = Succ&lt;_0&gt;;
</span><span class="boring">type _2 = Succ&lt;_1&gt;;
</span><span class="boring">type _3 = Succ&lt;_2&gt;;
</span><span class="boring">trait Lt&lt;A: Nat, B: Nat&gt; {
</span><span class="boring">    fn check() -&gt; () {}
</span><span class="boring">}
</span><span class="boring">struct ProofLt&lt;A: Nat, B: Nat&gt;(A, B);
</span><span class="boring">impl&lt;N: Nat&gt; Lt&lt;_0, N&gt; for ProofLt&lt;_0, N&gt; {}
</span><span class="boring">impl&lt;A: Nat, B: Nat&gt; Lt&lt;Succ&lt;A&gt;, Succ&lt;B&gt;&gt; for ProofLt&lt;Succ&lt;A&gt;, Succ&lt;B&gt;&gt;
</span><span class="boring">    where ProofLt&lt;A, B&gt;: Lt&lt;A, B&gt; {}
</span>
fn main() {
    // this is actually only using our base case of induction
    ProofLt::&lt;_0, _1&gt;::check();
    // now the real test
    ProofLt::&lt;_1, _3&gt;::check();
}
</code></pre></pre>
<p>Yay, it works! Now let's try to check whether it indeed rejects invalid examples.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Nat {}
</span><span class="boring">struct Succ&lt;T: Nat&gt;(T);
</span><span class="boring">struct _0;
</span><span class="boring">impl Nat for _0 {}
</span><span class="boring">impl&lt;T: Nat&gt; Nat for Succ&lt;T&gt; {}
</span><span class="boring">type _1 = Succ&lt;_0&gt;;
</span><span class="boring">type _2 = Succ&lt;_1&gt;;
</span><span class="boring">type _3 = Succ&lt;_2&gt;;
</span><span class="boring">trait Lt&lt;A: Nat, B: Nat&gt; {
</span><span class="boring">    fn check() -&gt; () {}
</span><span class="boring">}
</span><span class="boring">struct ProofLt&lt;A: Nat, B: Nat&gt;(A, B);
</span><span class="boring">impl&lt;N: Nat&gt; Lt&lt;_0, N&gt; for ProofLt&lt;_0, N&gt; {}
</span><span class="boring">impl&lt;A: Nat, B: Nat&gt; Lt&lt;Succ&lt;A&gt;, Succ&lt;B&gt;&gt; for ProofLt&lt;Succ&lt;A&gt;, Succ&lt;B&gt;&gt;
</span><span class="boring">    where ProofLt&lt;A, B&gt;: Lt&lt;A, B&gt; {}
</span>
fn main() {
    ProofLt::&lt;_3, _2&gt;::check();
}
</code></pre></pre>
<p>If we try to compile above code, the compiler would yell at us with something like</p>
<pre><code>///    | struct ProofLt&lt;A: Nat, B: Nat&gt;(A, B);
///    | -------------------------------------
///    | |
///    | function or associated item `check` not found for this
///    | doesn't satisfy `_: Lt&lt;Succ&lt;Succ&lt;Succ&lt;_0&gt;&gt;&gt;, Succ&lt;Succ&lt;_0&gt;&gt;&gt;`
///    | doesn't satisfy `_: Lt&lt;Succ&lt;Succ&lt;_0&gt;&gt;, Succ&lt;_0&gt;&gt;`
</code></pre>
<p>It failed to find associated function <code>check</code> because trait <code>Lt</code> is not implemented for this varian of <code>ProofLt</code>.</p>
<p>And this is exactly what we wanted to encode!</p>
<p>You can play around more with <code>ProofLt</code> and try to define new natural numbers.</p>
<pre><pre class="playground"><code class="language-rust editable">trait Nat {}
struct Succ&lt;T: Nat&gt;(T);

struct _0;
impl Nat for _0 {}
impl&lt;T: Nat&gt; Nat for Succ&lt;T&gt; {}

type _1 = Succ&lt;_0&gt;;
type _2 = Succ&lt;_1&gt;;
type _3 = Succ&lt;_2&gt;;

trait Lt&lt;A: Nat, B: Nat&gt; {
    fn check() -&gt; () {}
}

struct ProofLt&lt;A: Nat, B: Nat&gt;(A, B);
impl&lt;N: Nat&gt; Lt&lt;_0, N&gt; for ProofLt&lt;_0, N&gt; {}
impl&lt;A: Nat, B: Nat&gt; Lt&lt;Succ&lt;A&gt;, Succ&lt;B&gt;&gt; for ProofLt&lt;Succ&lt;A&gt;, Succ&lt;B&gt;&gt;
    where ProofLt&lt;A, B&gt;: Lt&lt;A, B&gt; {}

fn main () {
    // ProofLt::&lt;_2, _3&gt;::check()
}
</code></pre></pre>
<p>There's a link to Rust Playground to get a feel for it.</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9ad218fab3078069b67c90299db5c6b3">https://play.rust-lang.org/</a></p>
<p>This work was very much inspired by similar feature set of Scala that is using implicits as facts that can be derived on other types, if you are curious to learn more checke out this video by Rock The Jvm touching on a subject</p>
<p><a href="https://www.youtube.com/watch?v=qwUYqv6lKtQ">https://www.youtube.com/watch?v=qwUYqv6lKtQ</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
